Perfect ðŸ‘ you want **LangChain-style `@tool` decorators**, not `BaseTool` classes â€” simple functional tools that can later be plugged into an agent.

Letâ€™s build all **4 tools (`ReminderTool`, `ToDoListTool`, `WeatherTool`, `SearchTool`)** using `@tool` from `langchain.tools`.
Weâ€™ll use minimal clean functions â€” **no agents yet**, just callable tools.

---

### ðŸ“ Project structure

```
langchain_tools/
â”‚
â”œâ”€â”€ main.py
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ reminder_tool.py
â”‚   â”œâ”€â”€ todo_tool.py
â”‚   â”œâ”€â”€ weather_tool.py
â”‚   â””â”€â”€ search_tool.py
â”‚
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ reminders.json
â”‚   â””â”€â”€ todos.json
â”‚
â””â”€â”€ .env   # contains OPENWEATHER_API_KEY
```

---

### ðŸ§© `tools/reminder_tool.py`

```python
import json
import os
from langchain.tools import tool

DATA_PATH = "data/reminders.json"
os.makedirs("data", exist_ok=True)
if not os.path.exists(DATA_PATH):
    with open(DATA_PATH, "w") as f:
        json.dump([], f)

@tool("reminder_tool", return_direct=True)
def reminder_tool(action: str, reminder: str = None) -> str:
    """
    Manage reminders.
    action: 'add', 'list', 'delete'
    reminder: text of reminder (required for add/delete)
    """
    with open(DATA_PATH, "r") as f:
        reminders = json.load(f)

    if action == "add" and reminder:
        reminders.append(reminder)
        with open(DATA_PATH, "w") as f:
            json.dump(reminders, f, indent=2)
        return f"âœ… Reminder added: {reminder}"

    elif action == "list":
        if not reminders:
            return "No reminders found."
        return "\n".join([f"{i+1}. {r}" for i, r in enumerate(reminders)])

    elif action == "delete" and reminder:
        if reminder in reminders:
            reminders.remove(reminder)
            with open(DATA_PATH, "w") as f:
                json.dump(reminders, f, indent=2)
            return f"ðŸ—‘ï¸ Reminder deleted: {reminder}"
        else:
            return "Reminder not found."

    return "Invalid action or missing reminder."
```

---

### ðŸ§© `tools/todo_tool.py`

```python
import json
import os
from langchain.tools import tool

DATA_PATH = "data/todos.json"
os.makedirs("data", exist_ok=True)
if not os.path.exists(DATA_PATH):
    with open(DATA_PATH, "w") as f:
        json.dump([], f)

@tool("todo_tool", return_direct=True)
def todo_tool(action: str, task: str = None) -> str:
    """
    Manage a simple to-do list.
    action: 'add', 'list', 'delete'
    task: task text (required for add/delete)
    """
    with open(DATA_PATH, "r") as f:
        todos = json.load(f)

    if action == "add" and task:
        todos.append(task)
        with open(DATA_PATH, "w") as f:
            json.dump(todos, f, indent=2)
        return f"âœ… Task added: {task}"

    elif action == "list":
        if not todos:
            return "No tasks available."
        return "\n".join([f"{i+1}. {t}" for i, t in enumerate(todos)])

    elif action == "delete" and task:
        if task in todos:
            todos.remove(task)
            with open(DATA_PATH, "w") as f:
                json.dump(todos, f, indent=2)
            return f"ðŸ—‘ï¸ Task deleted: {task}"
        else:
            return "Task not found."

    return "Invalid action or missing task."
```

---

### ðŸ§© `tools/weather_tool.py`

```python
import requests
import os
from dotenv import load_dotenv
from langchain.tools import tool

load_dotenv()

API_KEY = os.getenv("OPENWEATHER_API_KEY")

@tool("weather_tool", return_direct=True)
def weather_tool(city: str) -> str:
    """
    Fetch real-time weather data for any city using OpenWeather API.
    """
    if not API_KEY:
        return "âŒ Missing OPENWEATHER_API_KEY in .env file."

    url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric"
    res = requests.get(url)

    if res.status_code != 200:
        return f"Error fetching weather: {res.text}"

    data = res.json()
    temp = data["main"]["temp"]
    desc = data["weather"][0]["description"]
    feels_like = data["main"]["feels_like"]
    humidity = data["main"]["humidity"]

    return f"ðŸŒ¤ï¸ Weather in {city}:\nTemp: {temp}Â°C\nFeels Like: {feels_like}Â°C\nCondition: {desc}\nHumidity: {humidity}%"
```

---

### ðŸ§© `tools/search_tool.py`

```python
from langchain.tools import tool
from langchain_community.utilities import SerpAPIWrapper

@tool("search_tool", return_direct=True)
def search_tool(query: str) -> str:
    """
    Perform a web search if information is not available in uploaded docs.
    Requires SERPAPI_API_KEY in environment.
    """
    search = SerpAPIWrapper()
    return search.run(query)
```

---

### ðŸ§  `main.py`

```python
from tools.reminder_tool import reminder_tool
from tools.todo_tool import todo_tool
from tools.weather_tool import weather_tool
from tools.search_tool import search_tool

def main():
    # ðŸ§© Directly invoke each tool
    print(reminder_tool.invoke({"action": "add", "reminder": "Buy groceries"}))
    print(reminder_tool.invoke({"action": "list"}))

    print(todo_tool.invoke({"action": "add", "task": "Finish assignment"}))
    print(todo_tool.invoke({"action": "list"}))

    print(weather_tool.invoke({"city": "Bangalore"}))

    print(search_tool.invoke({"query": "LangChain 2025 features"}))

if __name__ == "__main__":
    main()
```

---

### ðŸ§¾ `.env`

```
OPENWEATHER_API_KEY=your_openweather_api_key_here
SERPAPI_API_KEY=your_serpapi_api_key_here
```

---

âœ… **This setup:**

* Uses `@tool` for all four tools
* Keeps them stateless and lightweight
* Supports `.invoke()` calls (like LangChain expects)
* Is ready to plug into an Agent later

---

Would you like me to show you **how to register all these tools in a single `ToolKit`** (so they can be imported collectively by an agent later)?
