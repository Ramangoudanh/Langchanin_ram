@MCP.tool("query_decomposition_tool")
def query_decomposition_tool(user_query: str) -> str:
    """
    Breaks a complex research query into smaller, logically ordered sub-queries.

    Args:
        user_query (str): The main research question from the user.

    Returns:
        str: A structured JSON-like list of decomposed sub-queries.
    """

    prompt = f"""
    You are the Query Decomposition Engine for a research coordinator system.

    Task:
    - Decompose the following complex question into smaller, focused sub-queries.
    - Each sub-query should be research-ready (can be handled by Agents 2 â†’ 4).
    - Maintain logical order of investigation (background â†’ causes â†’ effects â†’ evidence â†’ conclusions).
    - Include short reasoning explaining why each sub-query is relevant.
    - Output as a JSON structure with two fields:
        "sub_queries": [ ... ],
        "rationale": "brief explanation of decomposition logic".

    ### Input Query:
    "{user_query}"

    ### Output Example:
    {{
      "sub_queries": [
         "What were the major government stimulus packages after COVID-19?",
         "How did renewable energy investment trends change in Asia between 2020-2024?",
         "What policy reforms supported green infrastructure financing post-COVID?",
         "What were the measurable impacts on carbon-neutral targets?"
      ],
      "rationale": "Divided into economic policy, investment trends, regulatory changes, and environmental outcomes for holistic coverage."
    }}
    """

    response = llm.invoke(prompt).content.strip()

    return f"ðŸ§© **Query Decomposition Result:**\n\n{response}"
